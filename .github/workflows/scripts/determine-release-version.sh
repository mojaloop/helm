#!/usr/bin/env bash

# Description: This script is used to the next release version number based on changes from last release.
# Dependencies: This script depends on the changelog files (.tmp/changelogs/**) generated by the generate-changelog.sh script.
# Requirements: bash, jq, awk, sed
# Usage: .github/workflows/scripts/determine-release-version last_release_tag

set -e

usage() {
    echo "determine-release-version [last_release_tag]"
}

####################################
# Environment and arguments check  #
####################################

# Check if the current shell is bash and the version is >= 4.0.0
if [ -z "$BASH_VERSION" ] || [ "${BASH_VERSION:0:1}" -lt 4 ]; then
    echo "This script requires bash >= v4.0.0. Please install bash >= v4.0.0 and try again."
    exit 1
fi

# We read the changelogs, commits, tags etc. from the temporary directory
dir=".tmp"

# Ensure .tmp/changelogs directory exists and there are files in there
if [ ! -d "$dir/changelogs" ] || [ ! "$(ls -A $dir/changelogs)" ]; then
    echo "The .tmp/changelogs directory does not exist or is empty. Please run the generate-changelog.sh script and try again."
    exit 1
fi

######################
# Global variables   #
######################

readonly MAJOR=0
readonly MINOR=1
readonly PATCH=2

# 'last_release_tag' is the last release tag, if not provided, it will be the last tag in the current branch
if [ -z "$1" ] || [ $1 == null ]; then
    last_release_tag=$(git describe --tags --abbrev=0)
else
    last_release_tag=$1
fi

######################
# Helper functions   #
######################

bump_version() {
    old_version=$1
    change_type=$2

    # Return a new version number based on the old version number and the change_type of change
    if [ $change_type == $MAJOR ]; then
        echo $old_version | awk -F. -v OFS=. '{$1++; $2=0; $3=0} 1'
    elif [ $change_type == $MINOR ]; then
        echo $old_version | awk -F. -v OFS=. '{$2++; $3=0} 1'
    elif [ $change_type == $PATCH ]; then
        echo $old_version | awk -F. -v OFS=. '{$3++} 1'
    fi
}

# Detect "Breaking Changes"
breaking_changes() {
    declare -A breaking_changes
    for file in $dir/changelogs/*.json
    do
        breaking_files=$(cat $file | jq -r '.files[] | select(.filename | contains("default.json", "migration"))')
        if [[ $breaking_files ]]
        then
            echo 0
            return
        fi
        breaking_commits=$(cat $file | jq -r '.commits[] | select(.commit.message | contains("BREAKING CHANGE"))')
        if [[ $breaking_commits ]]
        then
            echo 0
            return
        fi
    done
    echo 1
}

# Detect "New Features"
new_features() {
    new_features=""
    for file in $dir/changelogs/*.json
    do
        pr_title=$(cat $file |  jq -r '.commits[].commit | select(.message | startswith("feat")) .message | split("\n")[0] as $pr_title | "* \($pr_title)"')
        if [[ $pr_title ]]
        then
            echo 0;
            return
        fi
    done
    echo 1;
}

# Detect "Bug Fixes"
bug_fixes() {
    bug_fixes=""
    for file in $dir/changelogs/*.json
    do
        bug_fixes=$(cat $file |  jq -r '.commits[].commit | select(.message | startswith("fix(")) .message')
        if [[ $bug_fixes ]]
        then
            echo 0;
            return
        fi
    done
    echo 1;
}

# Remove leading "v"
last_version_number=$(echo $last_release_tag | sed 's/v//g')

breaking_changes_exist=$(breaking_changes)
if [[ $breaking_changes_exist == 0 ]]
then
    # Major version bump
    echo v$(bump_version $last_version_number $MAJOR)
    exit 0
fi

new_features_exist=$(new_features)
if [[ $new_features_exist == 0 ]]
then
    # Minor version bump
    echo v$(bump_version $last_version_number $MINOR)
    exit 0
fi

bug_fixes_exist=$(bug_fixes)
if [[ $bug_fixes_exist == 0 ]]
then
    # Patch version bump
    echo v$(bump_version $last_version_number $PATCH)
    exit 0
fi
